\section{Process}

At a high level, the process will transform a series of standard JavaScript $Array$ operators ($filter$, $map$,  $reduce$, $forEach$, $some$, $every$) into a standard for loop notation.  

The full algorithm can be broken into the following process:

\subsection{Transpile}
When transpiling the source files, we look for possible transformation patterns
  \begin{enumerate}
    \item Look for every possible indication that Array list operators are being used
    \begin{enumerate}
      \item Only $map$ and $filter$ reliably return new Arrays, whereas $some$, 
        $forEach$ and $every$ reliably return non-arrays.  $reduce$ can return 
        any value (and so we treat it as unknown)    
    \end{enumerate}
    \item When a potential Array operator site is found, modify source to
    \begin{enumerate} 
      \item	Wrap the Array expression with a $WRAP$ invocation, to provide an Array surrogate that can collect the operators
      \item	Wrap every function used by the operators with a $TAG$ invocation.  This provides additional metadata used for the compilation process
      \item	Wrap the potential Array expression and the subsequent operators with an $EXEC$ invocation to allow for compilation and execution of the collected operators
    \end{enumerate}    
  \end{enumerate}

  Sample Transpilation input  

  Sample Transpilation output  

\subsection{Runtime}
  At runtime time, the functions $KEY$, and $EXEC$ will perform all the necessary work to produce 
  and execute the optimized code
  \begin{enumerate}
    \item When transpiling a function or program context, allow for control of process by pragma
    \item When $WRAP$ is invoked, and the argument is an array, will produce a wrapper object that will collect 
      all the tagged operations ($filter$, $map$, $reduce$, etc.).  
    \item When $EXEC$ is invoked, if the input is a wrapper object, it will compile and execute the code.      
    \item When $WRAP$ is invoked with a non-array or $EXEC$ is invoked with a non-wrapper object, 
      it will return the input as is.  This allows for runtime type detection, and will not fail if 
      types are not-known at compile-time.          
  \end{enumerate}

\subsection{Compilation}
  When compiling the code, we analyze, and transform the operators into a for loop.  There are some
  caveats with transforming the code as some constructs prevent rewriting. The steps we follow are:

  \begin{enumerate}
    \item Generate the unique key to represent the combination and sequence of the operators in the series.  
    \item If the key has been seen before, return compiled output    
    \item Determine operator validity
    \begin {enumerate}
      \item Check for operator functions for intermediate array references. 
        $map$, $reduce$, $filter$, etc have a form in which the intermediate array 
        is accessible in a read only fashion.  If referencing, disqualify entire chain as
        it cannot be supported.
      \item When the array operator is a variable (and not a function literal), we need to check for closed 
        variables, since we are rewriting the function, any closed variable we do not have access to 
        will be lost.  
      \begin{enumerate}
        \item There is provision to allow for commonly used globals to not be considered closed 
          (and thusly disqualify rewriting).  
        \item All variables can shadowed at runtime, and we cannot determine
          the actual value looking at source alone. 
        \item Many global static functions can, and should assume will not be overwritten (e.g. String.fromCharCode, or Math.min)
      \end{enumerate}
      \item When the array operator is a function literal, it is in the scope of the current function, this gives 
        us some leeway. 
      \begin{enumerate}
        \item Closed variables generally are free to be ignored since we can account for them.
        \begin{enumerate}
          \item Pass in all closed variables into generated function
          \item Re-assign all closed variables that were written to, on completion of function
        \end{enumerate}
      \end{enumerate}
    \end{enumerate}
    \item If operator series is valid, build a new function by transforming the operators into a for loop
    \item Also note, we have the potential issue that that we will be modifying the function invocation order:
        \begin{lstlisting}[language=JavaScript] 
          [1,2].map(a).filter(b) 
        \end{lstlisting}

        will essentially turn into 

        \begin{lstlisting}[language=JavaScript]
          let out = []
          let af = map(1)
          if (filter(af)) out.push(af);
          let bf = map(2)
          if (filter(bf)) out.push(bf);
        \end{lstlisting}                

        This generally shouldn't matter,      
    \end{enumerate}