\subsection{Standard Deviation}\label{Standard Deviation}
A simple algorithm to compute the standard deviation of an array of numbers. It is computationally heavy.

For the most part, the optimized form outperforms the standard functional form (figures \ref{fig:std-dev:2x1..100000..5000}, \ref{fig:std-dev:1..100000..5000x2}, \ref{fig:std-dev:1..100000..5000x10}, \ref{fig:std-dev:10x1..100000..5000}, \ref{fig:std-dev:100x1..100000..5000}, \ref{fig:std-dev:1..100000..5000x100}). It also outperforms the manual form in all tests except figure \ref{fig:std-dev:2x1..100000..5000}. 

This is a surprising result in that the manual form should generally be better than optimized form.  This has a similar pattern to that of \secref{Sort Score Sum}, and shows how the underlying engine is sensitive to certain optimizations (e.g. removing closures and function parameters).

What you can also see, specifically in the test with a small input size of two (Iterations vs Time (ns) with an Input Size of two), is that there is a cost to the overhead of the optimized code.  It is small, but the underlying \javascript engine is able to execute the operations on a two element array faster than the generated \inlinecode{for} loop. 

As with all optimizations of this nature, there will be edge cases that the optimization does not perform as fast.  This comes down to the trade-off analysis of determining if the increased performance is worth the cost of code maintenance, in addition to looking at the other cases where the optimized form does outperform.