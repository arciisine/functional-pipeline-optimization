\chapter{Introduction}
In functional programming it is a common practice to handle traversing (looping) sequences ($map$, $filter$, $reduce$ \cite{TODO}. This form treats sequence traversal as a single operator ($map$, $filter$, $reduce$) with a function that operates on a single sequence element and has clear inputs and outputs.  Via functional composition (or method chaining), multiple operators are composed together to represent more complex traversals.  This abstraction comes with the cost of invoking a function per each element of the sequence and that is multiplied by number of operators that have been composed. In addition to the cost of function invocation, there is also significant memory usage for $filter$ and $map$ operations as each traversal will need to create an intermediate sequence (in addition to the original) to be used as input between operators (e.g. $map(filter(x, ...)...)$.  

A common optimization that is encouraged, throughout many programming languages, is to manually convert the functional traversal into a more traditional $for-loop$ \cite{TODO}.  This involves manually projecting the functional operator composition (and the companion functions) into standard procedural code.  While increasing performance and decreasing memory usage, the overall cost is tied to code maintainability and quality \cite{TODO}.  

The main trade-off of manual operation is pitting the programmer's desire (clean, testable code) against the processor's need for tight loops and register references \cite{TODO}.  