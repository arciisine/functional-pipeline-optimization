\chapter{Introduction}
In functional programming it is a common practice to handle traversing (looping) sequences by function invocation/recursion \cite{recurse16}.  Of the operators we are dealing with ($map$, $filter$, $reduce$), all can be written in terms of $reduce$, which is definable by recursion. Sequence traversal is treated as a single operator ($map$, $filter$, $reduce$) with a function that operates on a single sequence element. These functions have clear inputs and outputs per the JavaScript specification.  Via functional composition (or method chaining), multiple operators are composed together to represent more complex traversals.  This abstraction comes with the cost of invoking a function per each element of the sequence and that is multiplied by number of operators that have been composed. In addition to the cost of function invocation, there is also significant memory usage for $filter$ and $map$ operations as each traversal will need to create an intermediate sequence (in addition to the original) to be used as input between operators (e.g. $map(filter(x, ...)...)$.  

A common optimization that is encouraged, throughout many programming languages, is to manually convert the functional traversal into a more traditional $for-loop$ \cite{iterperf09} \cite{iterperf10} \cite{iterperf11}.  This involves manually projecting the functional operator composition (and the companion functions) into standard procedural code.  While increasing performance and decreasing memory usage, the overall cost is tied to code maintainability and quality \cite{TODO}.  

The main trade-off of manual operation is pitting the programmer's desire (clean, testable code) against the processor's need for tight loops and having as much of the code to be executed in a single function.  