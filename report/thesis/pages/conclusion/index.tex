\chapter{Conclusion}

The general concept of this algorithm has broad reaching implications.  At a high level, it is immediately obvious that removing array creation and function invocation will always produce faster code.  More specifically, is fairly obvious how to convert a simple functional traversal paradigm into procedural code, and maintain the correctness of the code. It is a simple operation in general, but the details are deceptively complex.

There may be gaps in the algorithm, but it's utility and power are obvious.  When used as a supplement to optimize functional code versus doing a manual transformation, it is able to gain immediate performance benefits without losing code clarity or maintainability.  And if manual optimization is still required to get the absolute performance out of a system, the optimization makes no requirement on the source code itself.    

From the scenario data, the algorithm performs extremely well even while dealing with the very flexible nature of JavaScript. It is not perfect or maximal in all scenarios, but it is consistently faster than the un-optimized functional form by a sizable factor.