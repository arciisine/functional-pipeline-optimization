\chapter{Conclusion}

The general concept of this algorithm has broad reaching implications.  At a high level, it is immediately obvious that removing array creation and function invocation will always produce faster code.  More specifically, any engineer can generally see how to convert a functional traversal paradigm into procedural code, and maintain the correctness of the code. It is a very simple operation in general, but the details are deceptively complex.

There may be gaps in the algorithm, but it's utility and power are obvious.  when used as a supplement to optimize functional code versus doing a manual transformation, it is easy to see immediate performance benefits without losing any of the code clarity or maintainability.  And if manual optimization is still required to get the absolute performance out of a system, the optimization makes no requirement on the source code itself.    

From the scenario data, the algorithm performs extremely well even while dealing with the very flexible nature of JavaScript. It is not perfect or maximal in all scenarios, but it is consistently faster than the un-optimized functional form by a sizable factor.

