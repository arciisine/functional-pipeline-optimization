\chapter{Conclusion}

The general concept of this algorithm has broad reaching implications.  At a high level, it is immediately obvious that removing array creation and function invocation will always produce faster code.  More specifically, any engineer can generally see how to convert a functional traversal paradigm into procedural code, and maintain the correctness of the code. It is a very simple operation in general, but the details are deceptively complex.

There may be gaps in the algorithm, but it's utility and power are obvious.  when used as a supplement to optimize functional code versus doing a manual transformation, it is easy to see immediate performance benefits without losing any of the code clarity or maintainability.  And if manual optimization is still required to get the absolute performance out of a system, the optimization makes no requirement on the source code itself.    

From the scenario data, the algorithm performs extremely well even while dealing with the very flexible nature of JavaScript. It is not perfect or maximal in all scenarios, but it is consistently faster than the un-optimized functional form by a sizable factor.

\chapter{Future Work}

The concept of composing functional operations at runtime or compile time as implications beyond JavaScript and array operators. Being able to support streams and generators would be of minor effort, but would allow for even more data types to qualify for the optimization.  Working with a language that is statically typed would remove a lot of the guess work from the process in general, and would allow for more consistent and rigorous optimizations.  Taking the optimization out of the JavaScript code and moving it into the engine would open up many more avenues for optimizations and would also minimize the duplicated effort in parsing and compiling the JavaScript code at runtime.

Beyond all of this, there are more general optimizations that could be made, by the nature of recompiling the code at runtime, and specifically merging multiple bodies of code together into a single function.  The v8 JavaScript engine is already great at optimizing where it can, but even just reducing the amount of code it has to evaluate, constant folding, algebraic simplifications, dead code elimination, etc. would be powerful enhancements.