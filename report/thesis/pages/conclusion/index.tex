\chapter{Conclusion}

The concept of this algorithm has broad reaching implications.  At a high level, it is clear that removing extraneous array creations and function invocations will always produce faster code.  More specifically, it is fairly straightforward to convert a simple functional traversal paradigm into procedural code, and maintain the correctness of the code. While being a seemingly simple operation, but the details are deceptively complex.

There may be gaps in the algorithm, but its utility and benefits are obvious.  When used as a supplement to optimize functional code versus doing a manual transformation, it is able to gain immediate performance benefits without losing code clarity or maintainability.  And if manual optimization is still required to get the absolute performance out of a system, the optimization makes no requirement on the source code itself.    

From the scenario data, the algorithm performs well even while dealing with the very flexible nature of JavaScript. It is not perfect or maximal in all scenarios, but it is consistently faster than the un-optimized functional form by a sizable factor.