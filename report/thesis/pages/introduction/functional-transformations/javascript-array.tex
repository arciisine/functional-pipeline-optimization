\section{Case Study: \javascript Array}

An implementation of this concept of functional sequences can be found in how \javascript models arrays.  The array class implements a super-set of the following functionality:

\begin{enumerate}
  \item \inlinecode{forEach(operation)}.  \inlinecode{operation} represents a generic function whose return value is ignored.  This method will invoke \inlinecode{operation} on every element of the array \cite{arrayforeach16}.

  \item \inlinecode{map(transform)}.  \inlinecode{transform} represents a mapping of the array contents.  This method will create a new array of identical size to the input, but with every element mapped through the \inlinecode{transform} function \cite{arraymap16}.

  \item \inlinecode{filter(predicate)}.  \inlinecode{predicate} represents a mapping of the array elements to a boolean value.  This method will return a new array in which every element that has a \inlinecode{predicate} invocation that returns \inlinecode{true} will be in the output \cite{arrayfilter16}.

  \item \inlinecode{reduce(accumulate, initial)}.  \inlinecode{accumulate} represents a function that receives both \inlinecode{accumulator} and an array element. Every time \inlinecode{accumulate} is invoked with \inlinecode{accumulator} and an array element, the output of the function is stored as a new value for \inlinecode{accumulate}.  This new value will be used on the next iteration or will be returned if it is the final iteration \cite{arrayreduce16}.

\end{enumerate}

Since \inlinecode{map} and \inlinecode{filter} both return arrays, this gives way to method chaining. Method chaining is a design pattern in which an operation on an object returns itself or an instance of the same type as the object. Visually, this produces a strong representation, as seen in listing \ref{lst:functional}, of the pseudo code.

\begin{minipage}{\linewidth}
\lstinputlisting[frame=single, caption={Functional implementation of findCommonWords}, label={lst:functional}, language=js]{code/sample-functional.js}
\end{minipage} 

\begin{minipage}{\linewidth}
\lstinputlisting[frame=single, caption={Functional implementation of findCommonWords with declared functions}, label={lst:functional-declared}, language=js]{code/sample-functional-declared.js}
\end{minipage}

An even clearer version of this code could be derived by declaring all the functions.  As shown in listing  \ref{lst:functional-declared}, this final form even allows for predicates/transformations to be used between multiple functional sequences.  This leads to higher quality of code by decreasing the testing surface, and preventing code duplication. 