\section{Functional Pipelines}
It is a common practice, in functional programming, to handle traversing (looping) sequences by function invocation/recursion \cite{recurse16}.  Of the operators we are dealing with (\inlinecode{map}, \inlinecode{filter}, \inlinecode{reduce}), all can be written in terms of \inlinecode{reduce}, which is definable by recursion. Sequence traversal is treated as a single operator (\inlinecode{map}, \inlinecode{filter}, \inlinecode{reduce}) with a function that operates on a single sequence element. These functions have clear inputs and outputs per the \javascript specification.  Via functional composition (or method chaining), multiple operators are composed together to represent more complex traversals.  This abstraction comes with the cost of invoking a function per each element of the sequence and that is multiplied by number of operators that have been composed. In addition to the cost of function invocation, there is also significant memory usage for \inlinecode{filter} and \inlinecode{map} operations as each traversal will need to create an intermediate sequence (in addition to the original) to be used as input between operators (e.g. \inlinecode{map(filter(x, ...)...)}).  
