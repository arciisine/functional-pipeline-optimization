\section{Functional Programming and Pipelines}
Functional programming is a paradigm that increases code maintainability and testability, but generally results in poorer resource utilization by the computer.  The increased resource cost versus code quality is usually an acceptable cost. However, code that is executed many times over, would benefit from optimization as the cost of the introduced abstractions are amplified. Specifically \pipelines (map, reduce, filter, etc.) are extremely sensitive to this overhead as the functional overhead is paid for each element in the list. In this paper we provide a framework for we provide a \javascript analysis framework that transforms \pipelines (e.g. \inlinecode{arr.map(x => x * 2).filter(x => x > 2)}) into \inlinecode{for} loops by combining source-level analysis and runtime evaluation to construct and compile optimized code at runtime.  This framework allows us to dynamically translate common \pipelines into a form that is optimized for computer execution, without modifying the original source code. This hybrid ultimately provides the best of both worlds, allowing the human to write and manage code in a manner that is familiar and more understandable, and for the final output to be in a form that executes with higher efficiency.

\subsection{Functional Pipelines}
It is a common practice, in functional programming, to handle traversing (looping) sequences by function invocation/recursion \cite{recurse16}.  Of the operators we are dealing with (\inlinecode{map}, \inlinecode{filter}, \inlinecode{reduce}), all can be written in terms of \inlinecode{reduce}, which is definable by recursion. Sequence traversal is treated as a single operator (\inlinecode{map}, \inlinecode{filter}, \inlinecode{reduce}) with a function that operates on a single sequence element. These functions have clear inputs and outputs per the \javascript specification.  Via functional composition (or method chaining), multiple operators are composed together to represent more complex traversals.  This abstraction comes with the cost of invoking a function per each element of the sequence and that is multiplied by number of operators that have been composed. In addition to the cost of function invocation, there is also significant memory usage for \inlinecode{filter} and \inlinecode{map} operations as each traversal will need to create an intermediate sequence (in addition to the original) to be used as input between operators (e.g. \inlinecode{map(filter(x, ...)...)}).  

\subsection{Functional Pipeline Operators}

\subsection{Performance Compensation}
A common optimization that is encouraged, throughout many programming languages, is to manually convert the functional traversal into a more traditional \inlinecode{for} loop \cite{iterperf09} \cite{iterperf10} \cite{iterperf11}.  This involves manually projecting the functional operator composition (and the companion functions) into standard procedural code.  While increasing performance and decreasing memory usage, the overall cost is tied to code maintainability and quality \cite{langstudy14}.  

The main trade-off of manual operation is pitting the programmer's desire for clean, testable code against the processor's need for tight loops and having as much of the code to be executed in a single function.  